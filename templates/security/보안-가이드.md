# Security CLAUDE.md - 웹 애플리케이션 보안 전문 가이드

> 이 문서는 Claude Code가 보안 모범 사례를 코딩에 즉시 적용할 수 있도록 작성된 상세 보안 가이드입니다.
> 프론트엔드 + 백엔드 공통으로 적용 가능하며, 바이브코딩 환경에 최적화되어 있습니다.

---

## 1. 보안 개요

### 1.1 핵심 보안 원칙

#### Defense in Depth (심층 방어)
단일 보안 계층에 의존하지 않는다. 여러 겹의 보안 계층을 구성하여 하나가 뚫려도 다음 계층이 방어한다.
- 네트워크 계층: 방화벽, WAF, DDoS 방어
- 애플리케이션 계층: 입력 검증, 출력 인코딩, 인증/인가
- 데이터 계층: 암호화, 접근 제어, 백업
- 모니터링 계층: 로깅, 알림, 감사 추적

#### Least Privilege (최소 권한)
모든 사용자, 프로세스, 시스템은 작업 수행에 필요한 최소한의 권한만 가진다.
- 데이터베이스 계정은 필요한 테이블에만 접근
- API 키는 필요한 엔드포인트에만 접근
- 서비스 계정은 필요한 리소스에만 접근
- 컨테이너는 비루트 사용자로 실행

#### Zero Trust (제로 트러스트)
네트워크 위치에 관계없이 모든 요청을 검증한다. 내부 네트워크라도 신뢰하지 않는다.
- 모든 API 요청에 인증/인가 적용
- 서비스 간 통신도 mTLS로 암호화
- 지속적인 검증 (매 요청마다)
- 마이크로세그멘테이션 적용

### 1.2 보안 개발 생명주기 (SDL)

| 단계 | 활동 | 도구/방법 |
|------|------|-----------|
| 요구사항 | 보안 요구사항 정의, 위협 모델링 | STRIDE, DREAD |
| 설계 | 보안 설계 리뷰, 아키텍처 리뷰 | 위협 모델링 도구 |
| 구현 | 보안 코딩 표준 준수, 정적 분석 | SAST (SonarQube, Semgrep) |
| 테스트 | 보안 테스트, 침투 테스트 | DAST (ZAP), SCA (Snyk) |
| 배포 | 보안 설정 검증, 시크릿 관리 | Vault, AWS SM |
| 운영 | 모니터링, 사고 대응, 패치 관리 | SIEM, WAF |

### 1.3 OWASP Top 10 2021 요약

| 순위 | 항목 | 설명 | CWE 수 |
|------|------|------|--------|
| A01 | Broken Access Control | 접근 제어 실패 | 34 |
| A02 | Cryptographic Failures | 암호화 실패 | 29 |
| A03 | Injection | 인젝션 공격 | 33 |
| A04 | Insecure Design | 불안전한 설계 | 40 |
| A05 | Security Misconfiguration | 보안 설정 오류 | 20 |
| A06 | Vulnerable Components | 취약한 컴포넌트 | 3 |
| A07 | Auth Failures | 인증 실패 | 22 |
| A08 | Data Integrity Failures | 데이터 무결성 실패 | 10 |
| A09 | Logging Failures | 로깅/모니터링 실패 | 4 |
| A10 | SSRF | 서버사이드 요청 위조 | 1 |

### 1.4 보안 사고 대응 프로세스 개요
1. **탐지(Detection)**: 이상 징후 감지, 알림 수신
2. **분류(Triage)**: 심각도 판정, 대응 팀 구성
3. **격리(Containment)**: 영향 범위 제한, 추가 피해 방지
4. **분석(Analysis)**: 근본 원인 분석, 공격 벡터 파악
5. **복구(Recovery)**: 시스템 복원, 패치 적용
6. **교훈(Lessons Learned)**: 사후 분석, 재발 방지 대책

### 1.5 이 문서의 사용법
- 새 기능 개발 시: 관련 섹션을 참조하여 보안 요구사항 확인
- 코드 리뷰 시: 체크리스트(섹션 8) 활용
- 보안 이슈 발견 시: 해당 OWASP 항목 참조
- Claude Code에 이 파일을 포함시키면 자동으로 보안 모범 사례 적용

---

## 2. OWASP Top 10 상세 대응

### 2.1 A01: Broken Access Control (접근 제어 실패)

접근 제어는 사용자가 허용된 범위를 넘어 행동하지 못하도록 하는 정책이다. 이 항목의 실패는 무단 정보 공개, 수정, 삭제 또는 사용자 권한 밖의 비즈니스 기능 수행으로 이어진다.

#### 2.1.1 수평적/수직적 권한 상승 방지

**수평적 권한 상승**: 동일 권한 수준의 다른 사용자 리소스에 접근
**수직적 권한 상승**: 더 높은 권한 수준의 기능에 접근

```javascript
// [위험] 수평적 권한 상승에 취약한 코드
app.get('/api/users/:id/profile', (req, res) => {
  const user = await User.findById(req.params.id);
  res.json(user); // 누구나 다른 사용자 프로필 조회 가능
});

// [안전] 리소스 소유권 검증
app.get('/api/users/:id/profile', authenticate, (req, res) => {
  if (req.user.id !== req.params.id && !req.user.hasRole('admin')) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  const user = await User.findById(req.params.id);
  res.json(user);
});
```

```java
// [위험] 수직적 권한 상승에 취약한 코드
@GetMapping("/admin/users")
public List<User> getAllUsers() {
    return userRepository.findAll(); // 권한 검사 없음
}

// [안전] 역할 기반 접근 제어 적용
@GetMapping("/admin/users")
@PreAuthorize("hasRole('ADMIN')")
public List<User> getAllUsers() {
    return userRepository.findAll();
}
```

#### 2.1.2 RBAC (Role-Based Access Control) 구현 패턴

```typescript
// 역할 정의
enum Role {
  VIEWER = 'viewer',
  EDITOR = 'editor',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin',
}

// 권한 정의
enum Permission {
  READ_POSTS = 'read:posts',
  CREATE_POSTS = 'create:posts',
  UPDATE_POSTS = 'update:posts',
  DELETE_POSTS = 'delete:posts',
  MANAGE_USERS = 'manage:users',
  MANAGE_ROLES = 'manage:roles',
}

// 역할-권한 매핑
const rolePermissions: Record<Role, Permission[]> = {
  [Role.VIEWER]: [Permission.READ_POSTS],
  [Role.EDITOR]: [Permission.READ_POSTS, Permission.CREATE_POSTS, Permission.UPDATE_POSTS],
  [Role.ADMIN]: [
    Permission.READ_POSTS, Permission.CREATE_POSTS,
    Permission.UPDATE_POSTS, Permission.DELETE_POSTS,
    Permission.MANAGE_USERS,
  ],
  [Role.SUPER_ADMIN]: Object.values(Permission),
};

// RBAC 미들웨어
function requirePermission(...permissions: Permission[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.role as Role;
    if (!userRole) return res.status(401).json({ error: 'Unauthorized' });

    const userPermissions = rolePermissions[userRole] || [];
    const hasPermission = permissions.every(p => userPermissions.includes(p));

    if (!hasPermission) return res.status(403).json({ error: 'Forbidden' });
    next();
  };
}

// 사용 예시
app.delete('/api/posts/:id', requirePermission(Permission.DELETE_POSTS), deletePost);
```

#### 2.1.3 ABAC (Attribute-Based Access Control) 구현 패턴

```typescript
// 정책 정의
interface Policy {
  effect: 'allow' | 'deny';
  conditions: PolicyCondition[];
}

interface PolicyCondition {
  attribute: string;
  operator: 'eq' | 'neq' | 'in' | 'gt' | 'lt';
  value: unknown;
}

// ABAC 엔진
class ABACEngine {
  evaluate(subject: User, resource: Resource, action: string, policies: Policy[]): boolean {
    const context = {
      'subject.role': subject.role,
      'subject.department': subject.department,
      'subject.id': subject.id,
      'resource.owner': resource.ownerId,
      'resource.department': resource.department,
      'resource.classification': resource.classification,
      'action': action,
      'env.time': new Date().getHours(),
      'env.ip': subject.ipAddress,
    };

    for (const policy of policies) {
      const matches = policy.conditions.every(cond =>
        this.evaluateCondition(context[cond.attribute], cond.operator, cond.value)
      );
      if (matches) return policy.effect === 'allow';
    }
    return false; // 기본 거부
  }

  private evaluateCondition(actual: unknown, operator: string, expected: unknown): boolean {
    switch (operator) {
      case 'eq': return actual === expected;
      case 'neq': return actual !== expected;
      case 'in': return Array.isArray(expected) && expected.includes(actual);
      case 'gt': return (actual as number) > (expected as number);
      case 'lt': return (actual as number) < (expected as number);
      default: return false;
    }
  }
}
```

#### 2.1.4 CORS 설정 모범 사례

```typescript
// [위험] 모든 오리진 허용
app.use(cors({ origin: '*' }));

// [위험] 요청 오리진을 그대로 반영
app.use(cors({ origin: req.headers.origin }));

// [안전] 허용 오리진 화이트리스트
const allowedOrigins = [
  'https://app.example.com',
  'https://admin.example.com',
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('CORS not allowed'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400,
}));
```

#### 2.1.5 디렉토리 트래버설 방지

```typescript
import path from 'path';

// [위험] 경로 검증 없이 파일 제공
app.get('/files/:filename', (req, res) => {
  res.sendFile(`/uploads/${req.params.filename}`);
});

// [안전] 경로 정규화 및 검증
app.get('/files/:filename', (req, res) => {
  const basePath = path.resolve('/uploads');
  const filePath = path.resolve(basePath, req.params.filename);

  // 기본 경로 이탈 확인
  if (!filePath.startsWith(basePath)) {
    return res.status(400).json({ error: 'Invalid file path' });
  }

  // 허용 확장자 확인
  const allowedExtensions = ['.pdf', '.png', '.jpg', '.jpeg'];
  const ext = path.extname(filePath).toLowerCase();
  if (!allowedExtensions.includes(ext)) {
    return res.status(400).json({ error: 'File type not allowed' });
  }

  res.sendFile(filePath);
});
```

### 2.2 A02: Cryptographic Failures (암호화 실패)

#### 2.2.1 전송 중 암호화

```nginx
# Nginx TLS 설정 모범 사례
server {
    listen 443 ssl http2;

    ssl_certificate /etc/ssl/certs/example.crt;
    ssl_certificate_key /etc/ssl/private/example.key;

    # TLS 1.2 이상만 허용 (TLS 1.3 권장)
    ssl_protocols TLSv1.2 TLSv1.3;

    # 강력한 암호 스위트만 사용
    ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;

    # HSTS 헤더 (2년, 서브도메인 포함)
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
}

# HTTP -> HTTPS 리다이렉트
server {
    listen 80;
    return 301 https://$host$request_uri;
}
```

#### 2.2.2 비밀번호 해싱 비교

| 알고리즘 | 특징 | 권장 여부 | 사용처 |
|---------|------|----------|--------|
| MD5/SHA-1 | 빠름, 레인보우 테이블 취약 | 절대 사용 금지 | - |
| SHA-256 | 빠름, 솔트 없음 | 비밀번호용 부적합 | 데이터 무결성 |
| bcrypt | 적응형 해싱, 솔트 내장 | 권장 | 대부분의 경우 |
| scrypt | 메모리 집약적 | 권장 | 추가 보호 필요 시 |
| Argon2id | 최신, 메모리+시간 설정 | 가장 권장 | 새 프로젝트 |

```typescript
// bcrypt 사용 (Node.js)
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12; // 최소 10, 권장 12

async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}
```

```java
// Argon2 사용 (Java - Spring Security)
@Bean
public PasswordEncoder passwordEncoder() {
    return new Argon2PasswordEncoder(
        16,   // saltLength
        32,   // hashLength
        1,    // parallelism
        65536, // memory (KB)
        3     // iterations
    );
}
```

#### 2.2.3 저장 시 암호화

```typescript
import crypto from 'crypto';

// AES-256-GCM 암호화/복호화
class FieldEncryptor {
  private algorithm = 'aes-256-gcm';

  encrypt(plaintext: string, key: Buffer): { ciphertext: string; iv: string; tag: string } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);

    let ciphertext = cipher.update(plaintext, 'utf8', 'base64');
    ciphertext += cipher.final('base64');
    const tag = cipher.getAuthTag();

    return {
      ciphertext,
      iv: iv.toString('base64'),
      tag: tag.toString('base64'),
    };
  }

  decrypt(ciphertext: string, key: Buffer, iv: string, tag: string): string {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      Buffer.from(iv, 'base64')
    );
    decipher.setAuthTag(Buffer.from(tag, 'base64'));

    let plaintext = decipher.update(ciphertext, 'base64', 'utf8');
    plaintext += decipher.final('utf8');
    return plaintext;
  }
}
```

#### 2.2.4 암호화 키 관리 전략

| 방법 | 장점 | 단점 | 적합한 환경 |
|------|------|------|------------|
| 환경변수 | 간단 | 로그 노출 위험 | 개발/소규모 |
| HashiCorp Vault | 동적 시크릿, 감사 | 운영 복잡 | 중대규모 |
| AWS KMS | AWS 통합, 관리형 | 벤더 종속 | AWS 환경 |
| GCP Cloud KMS | GCP 통합, 관리형 | 벤더 종속 | GCP 환경 |
| Azure Key Vault | Azure 통합, 관리형 | 벤더 종속 | Azure 환경 |

### 2.3 A03: Injection (인젝션)

#### 2.3.1 SQL Injection 방지

```typescript
// [위험] 문자열 연결을 사용한 쿼리
const query = `SELECT * FROM users WHERE email = '${email}' AND password = '${password}'`;
db.query(query);

// [안전] 파라미터 바인딩 (Prepared Statement)
const query = 'SELECT * FROM users WHERE email = $1 AND password = $2';
db.query(query, [email, hashedPassword]);

// [안전] ORM 사용 (Prisma)
const user = await prisma.user.findUnique({
  where: { email },
});

// [안전] ORM 사용 (TypeORM)
const user = await userRepository.findOne({
  where: { email },
});
```

```java
// [위험] 문자열 연결
String query = "SELECT * FROM users WHERE email = '" + email + "'";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(query);

// [안전] PreparedStatement
String query = "SELECT * FROM users WHERE email = ?";
PreparedStatement pstmt = conn.prepareStatement(query);
pstmt.setString(1, email);
ResultSet rs = pstmt.executeQuery();

// [안전] JPA/Hibernate
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);

    // 네이밍 쿼리 사용 (파라미터 자동 바인딩)
    @Query("SELECT u FROM User u WHERE u.email = :email AND u.status = :status")
    List<User> findByEmailAndStatus(@Param("email") String email, @Param("status") String status);
}
```

#### 2.3.2 NoSQL Injection 방지

```typescript
// [위험] MongoDB - 사용자 입력을 직접 쿼리에 사용
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  // 공격자: { "username": {"$gt": ""}, "password": {"$gt": ""} }
  const user = await db.collection('users').findOne({ username, password });
});

// [안전] 입력 타입 검증 + 파라미터 제한
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  if (typeof username !== 'string' || typeof password !== 'string') {
    return res.status(400).json({ error: 'Invalid input' });
  }

  const user = await db.collection('users').findOne({
    username: { $eq: username },
  });

  if (!user || !(await bcrypt.compare(password, user.passwordHash))) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
});
```

#### 2.3.3 OS Command Injection 방지

```typescript
import { execFile } from 'child_process';

// [위험] exec로 사용자 입력을 셸에 전달
import { exec } from 'child_process';
app.get('/ping', (req, res) => {
  exec(`ping -c 4 ${req.query.host}`, (err, stdout) => {
    res.send(stdout);
  });
  // 공격: ?host=google.com;rm%20-rf%20/
});

// [안전] execFile + 화이트리스트 검증
app.get('/ping', (req, res) => {
  const host = req.query.host as string;

  // IP 주소 또는 도메인 형식만 허용
  const hostPattern = /^[a-zA-Z0-9][a-zA-Z0-9.-]{0,253}[a-zA-Z0-9]$/;
  if (!hostPattern.test(host)) {
    return res.status(400).json({ error: 'Invalid host format' });
  }

  // execFile은 셸을 거치지 않아 명령 주입 방지
  execFile('ping', ['-c', '4', host], (err, stdout) => {
    res.send(stdout);
  });
});
```

#### 2.3.4 Expression Language Injection 방지

```java
// [위험] SpEL - 사용자 입력을 표현식으로 평가
SpelExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(userInput); // 절대 금지
Object result = exp.getValue();

// [안전] SpEL 사용 시 SimpleEvaluationContext 사용
SimpleEvaluationContext context = SimpleEvaluationContext
    .forReadOnlyDataBinding()
    .withInstanceMethods()
    .build();
Expression exp = parser.parseExpression(safeExpression);
Object result = exp.getValue(context, targetObject);
```

### 2.4 A04: Insecure Design (불안전한 설계)

#### 2.4.1 위협 모델링 (STRIDE)

| 위협 유형 | 설명 | 대응 원칙 | 예시 |
|----------|------|----------|------|
| **S**poofing | 신원 위장 | 인증 | 가짜 로그인 페이지 |
| **T**ampering | 데이터 변조 | 무결성 | 쿠키/파라미터 조작 |
| **R**epudiation | 부인 | 감사 로깅 | 거래 부인 |
| **I**nformation Disclosure | 정보 노출 | 기밀성 | 에러 메시지로 DB 구조 노출 |
| **D**enial of Service | 서비스 거부 | 가용성 | API 과다 호출 |
| **E**levation of Privilege | 권한 상승 | 인가 | 일반 사용자가 관리자 기능 접근 |

#### 2.4.2 Rate Limiting 구현 패턴

```typescript
// express-rate-limit 사용
import rateLimit from 'express-rate-limit';

// 전역 Rate Limit
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // 15분당 100 요청
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, please try again later' },
});

// 로그인 엔드포인트 Rate Limit (더 엄격)
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 15분당 5회 시도
  skipSuccessfulRequests: true,
  keyGenerator: (req) => req.body.email || req.ip, // 이메일 기준 제한
});

// API 엔드포인트별 Rate Limit
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1분
  max: 30,
  keyGenerator: (req) => req.user?.id || req.ip,
});

app.use(globalLimiter);
app.post('/auth/login', loginLimiter, loginHandler);
app.use('/api/', apiLimiter);
```

#### 2.4.3 계정 잠금 정책

```typescript
// 계정 잠금 구현
class AccountLockoutService {
  private readonly MAX_ATTEMPTS = 5;
  private readonly LOCKOUT_DURATION_MS = 30 * 60 * 1000; // 30분
  private readonly PROGRESSIVE_DELAYS = [0, 0, 2000, 5000, 10000]; // 점진적 지연

  async handleLoginAttempt(email: string, success: boolean): Promise<void> {
    const account = await this.getAccountLockInfo(email);

    if (success) {
      await this.resetAttempts(email);
      return;
    }

    const attempts = account.failedAttempts + 1;
    await this.recordFailedAttempt(email, attempts);

    if (attempts >= this.MAX_ATTEMPTS) {
      await this.lockAccount(email, this.LOCKOUT_DURATION_MS);
      await this.notifyUser(email, 'Account locked due to multiple failed login attempts');
    }
  }

  async isAccountLocked(email: string): Promise<boolean> {
    const account = await this.getAccountLockInfo(email);
    if (!account.lockedUntil) return false;
    if (new Date() > account.lockedUntil) {
      await this.resetAttempts(email);
      return false;
    }
    return true;
  }

  getDelay(attempts: number): number {
    return this.PROGRESSIVE_DELAYS[Math.min(attempts, this.PROGRESSIVE_DELAYS.length - 1)];
  }
}
```

### 2.5 A05: Security Misconfiguration (보안 설정 오류)

#### 2.5.1 보안 헤더 전체 설정

```typescript
import helmet from 'helmet';

// Helmet으로 기본 보안 헤더 설정
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'nonce-{RANDOM}'"],
      styleSrc: ["'self'", "'unsafe-inline'"], // CSS-in-JS 사용 시
      imgSrc: ["'self'", "data:", "https:"],
      fontSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.example.com"],
      frameSrc: ["'none'"],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      upgradeInsecureRequests: [],
    },
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: "same-site" },
  dnsPrefetchControl: { allow: false },
  frameguard: { action: 'deny' },
  hsts: { maxAge: 63072000, includeSubDomains: true, preload: true },
  ieNoOpen: true,
  noSniff: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  xssFilter: true,
}));
```

| 헤더 | 값 | 설명 |
|------|---|------|
| Content-Security-Policy | 위 참조 | XSS 방지, 리소스 로딩 제어 |
| Strict-Transport-Security | max-age=63072000 | HTTPS 강제 |
| X-Content-Type-Options | nosniff | MIME 타입 스니핑 방지 |
| X-Frame-Options | DENY | 클릭재킹 방지 |
| X-XSS-Protection | 0 | 레거시 XSS 필터 비활성화 (CSP 사용) |
| Referrer-Policy | strict-origin-when-cross-origin | 리퍼러 정보 제한 |
| Permissions-Policy | camera=(), microphone=() | 브라우저 기능 제한 |

#### 2.5.2 에러 메시지 관리

```typescript
// [위험] 상세 에러 정보 노출
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  res.status(500).json({
    error: err.message,
    stack: err.stack,          // 스택 트레이스 노출
    query: req.query,          // 쿼리 파라미터 노출
    dbError: err.cause,        // 내부 에러 노출
  });
});

// [안전] 일반적인 에러 메시지 + 내부 로깅
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  const errorId = crypto.randomUUID();

  // 내부 로깅 (상세 정보 포함)
  logger.error({
    errorId,
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    userId: req.user?.id,
    timestamp: new Date().toISOString(),
  });

  // 클라이언트 응답 (최소 정보)
  const statusCode = err instanceof AppError ? err.statusCode : 500;
  res.status(statusCode).json({
    error: statusCode === 500 ? 'Internal server error' : err.message,
    errorId, // 추적용 ID만 제공
  });
});
```

#### 2.5.3 Docker/컨테이너 보안 설정

```dockerfile
# [안전] 보안 강화된 Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:20-alpine

# 비루트 사용자 생성
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

WORKDIR /app

# 프로덕션 의존성만 복사
COPY --from=builder /app/node_modules ./node_modules
COPY --chown=appuser:appgroup . .

# 비루트 사용자로 실행
USER appuser

# 읽기 전용 파일시스템
# docker run --read-only --tmpdir /tmp

EXPOSE 3000

# PID 1 문제 해결
CMD ["node", "--max-old-space-size=512", "dist/server.js"]
```

### 2.6 A06: Vulnerable and Outdated Components (취약한 컴포넌트)

#### 2.6.1 의존성 보안 스캐닝

```json
// package.json - 보안 스크립트 추가
{
  "scripts": {
    "audit": "npm audit --production",
    "audit:fix": "npm audit fix",
    "audit:ci": "npm audit --production --audit-level=high",
    "snyk:test": "snyk test --severity-threshold=high",
    "snyk:monitor": "snyk monitor"
  }
}
```

#### 2.6.2 SCA 도구 비교

| 도구 | 언어 지원 | 라이선스 | 특징 |
|------|----------|---------|------|
| npm audit | Node.js | 무료 | npm 내장, 기본적 |
| Snyk | 다중 언어 | 무료/유료 | 자동 PR, 광범위 DB |
| OWASP Dep-Check | Java 중심 | 무료 | NVD 기반 |
| Trivy | 다중 언어 | 무료 | 컨테이너 스캔 포함 |
| Dependabot | GitHub | 무료 | GitHub 통합, 자동 PR |
| Renovate | 다중 플랫폼 | 무료 | 유연한 설정 |

#### 2.6.3 자동 업데이트 설정 (Renovate)

```json
// renovate.json
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:recommended", "security:openssf-scorecard"],
  "vulnerabilityAlerts": { "enabled": true },
  "packageRules": [
    {
      "matchUpdateTypes": ["patch"],
      "automerge": true,
      "automergeType": "branch"
    },
    {
      "matchUpdateTypes": ["minor"],
      "automerge": false,
      "labels": ["dependencies", "minor"]
    },
    {
      "matchUpdateTypes": ["major"],
      "automerge": false,
      "labels": ["dependencies", "major", "review-required"]
    }
  ],
  "schedule": ["before 6am on Monday"]
}
```

### 2.7 A07: Identification and Authentication Failures (인증 실패)

#### 2.7.1 비밀번호 정책

```typescript
// 비밀번호 강도 검증
class PasswordPolicy {
  private readonly MIN_LENGTH = 12;
  private readonly MAX_LENGTH = 128;
  private readonly COMMON_PASSWORDS = new Set(/* 상위 10000개 비밀번호 로드 */);

  validate(password: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (password.length < this.MIN_LENGTH) {
      errors.push(`최소 ${this.MIN_LENGTH}자 이상이어야 합니다`);
    }
    if (password.length > this.MAX_LENGTH) {
      errors.push(`최대 ${this.MAX_LENGTH}자를 초과할 수 없습니다`);
    }
    if (!/[a-z]/.test(password)) {
      errors.push('소문자를 포함해야 합니다');
    }
    if (!/[A-Z]/.test(password)) {
      errors.push('대문자를 포함해야 합니다');
    }
    if (!/\d/.test(password)) {
      errors.push('숫자를 포함해야 합니다');
    }
    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('특수문자를 포함해야 합니다');
    }
    if (this.COMMON_PASSWORDS.has(password.toLowerCase())) {
      errors.push('자주 사용되는 비밀번호는 사용할 수 없습니다');
    }

    return { valid: errors.length === 0, errors };
  }
}
```

#### 2.7.2 세션 관리

```typescript
import session from 'express-session';
import RedisStore from 'connect-redis';
import { createClient } from 'redis';

const redisClient = createClient({ url: process.env.REDIS_URL });
await redisClient.connect();

app.use(session({
  store: new RedisStore({ client: redisClient, prefix: 'sess:' }),
  name: '__Host-sid', // 쿠키 접두사로 보안 강화
  secret: process.env.SESSION_SECRET!,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,       // HTTPS만
    httpOnly: true,      // JavaScript 접근 차단
    sameSite: 'strict',  // CSRF 방지
    maxAge: 30 * 60 * 1000, // 30분
    path: '/',
    domain: '.example.com',
  },
  rolling: true, // 활동 시 세션 갱신
}));

// 세션 고정(fixation) 방지 - 로그인 후 세션 재생성
app.post('/auth/login', async (req, res) => {
  const user = await authenticateUser(req.body);
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  // 기존 세션 파괴 후 새 세션 생성
  req.session.regenerate((err) => {
    if (err) return res.status(500).json({ error: 'Session error' });
    req.session.userId = user.id;
    req.session.role = user.role;
    req.session.createdAt = Date.now();
    res.json({ success: true });
  });
});
```

#### 2.7.3 브루트 포스 방지

| 방법 | 설명 | 구현 복잡도 | 효과 |
|------|------|-----------|------|
| Rate Limiting | IP/계정별 요청 제한 | 낮음 | 높음 |
| Progressive Delay | 실패 시 지연 증가 | 중간 | 높음 |
| Account Lockout | N회 실패 시 잠금 | 중간 | 높음 (DoS 위험) |
| CAPTCHA | 봇 방지 | 낮음 | 중간 |
| MFA | 2차 인증 | 중간 | 매우 높음 |
| Credential Stuffing 방지 | 유출 DB 체크 | 높음 | 높음 |

### 2.8 A08: Software and Data Integrity Failures (데이터 무결성 실패)

#### 2.8.1 CI/CD 파이프라인 보안

```yaml
# GitHub Actions 보안 강화
name: Secure CI/CD Pipeline
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read  # 최소 권한 원칙

jobs:
  security-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 의존성 잠금 파일 검증
      - name: Verify lockfile integrity
        run: npm ci --ignore-scripts

      # SAST
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/owasp-top-ten

      # SCA
      - name: Run npm audit
        run: npm audit --production --audit-level=high

      # 시크릿 스캔
      - name: Run gitleaks
        uses: gitleaks/gitleaks-action@v2

      # 컨테이너 이미지 스캔
      - name: Run Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
```

#### 2.8.2 SRI (Subresource Integrity)

```html
<!-- [위험] SRI 없이 외부 스크립트 로드 -->
<script src="https://cdn.example.com/lib.js"></script>

<!-- [안전] SRI 해시 포함 -->
<script
  src="https://cdn.example.com/lib.js"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8w"
  crossorigin="anonymous"
></script>
```

#### 2.8.3 안전한 역직렬화

```java
// [위험] 신뢰할 수 없는 데이터 역직렬화
ObjectInputStream ois = new ObjectInputStream(userInputStream);
Object obj = ois.readObject(); // 원격 코드 실행 가능

// [안전] 허용 클래스 화이트리스트 적용
ObjectInputStream ois = new ObjectInputStream(userInputStream) {
    @Override
    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        Set<String> allowedClasses = Set.of("com.example.dto.UserDTO", "com.example.dto.OrderDTO");
        if (!allowedClasses.contains(desc.getName())) {
            throw new InvalidClassException("Unauthorized deserialization", desc.getName());
        }
        return super.resolveClass(desc);
    }
};

// [권장] JSON 직렬화 사용 (Java 직렬화 대신)
ObjectMapper mapper = new ObjectMapper();
mapper.activateDefaultTyping(
    mapper.getPolymorphicTypeValidator(),
    ObjectMapper.DefaultTyping.NON_FINAL
);
UserDTO user = mapper.readValue(jsonString, UserDTO.class);
```

### 2.9 A09: Security Logging and Monitoring Failures (로깅/모니터링 실패)

#### 2.9.1 보안 로깅 체크리스트

**반드시 로깅해야 하는 이벤트:**
- 인증 성공/실패
- 인가 실패 (403)
- 입력 검증 실패
- 세션 생성/파괴
- 권한 변경
- 관리자 작업
- 데이터 수정/삭제
- 시스템 오류 (500)
- 비정상적 요청 패턴

**절대 로그에 포함하면 안 되는 정보:**
- 비밀번호 (평문/해시 포함)
- 신용카드 번호
- 주민등록번호
- API 키/시크릿
- 세션 토큰
- JWT 토큰
- 개인 건강 정보

#### 2.9.2 구조화 로깅

```typescript
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  formatters: {
    level: (label) => ({ level: label }),
  },
  redact: {
    paths: ['password', 'token', 'authorization', 'cookie', 'ssn', 'creditCard'],
    censor: '[REDACTED]',
  },
  timestamp: pino.stdTimeFunctions.isoTime,
});

// 보안 이벤트 로깅
function logSecurityEvent(event: {
  type: 'auth_success' | 'auth_failure' | 'authz_failure' | 'input_validation' | 'suspicious_activity';
  userId?: string;
  ip: string;
  userAgent: string;
  details: Record<string, unknown>;
}) {
  logger.warn({
    category: 'security',
    eventType: event.type,
    userId: event.userId,
    sourceIp: event.ip,
    userAgent: event.userAgent,
    timestamp: new Date().toISOString(),
    ...event.details,
  });
}
```

### 2.10 A10: Server-Side Request Forgery (SSRF)

#### 2.10.1 SSRF 방지 패턴

```typescript
import { URL } from 'url';
import dns from 'dns/promises';
import net from 'net';

class SSRFProtection {
  // 내부 IP 대역 차단
  private readonly BLOCKED_RANGES = [
    '10.0.0.0/8',
    '172.16.0.0/12',
    '192.168.0.0/16',
    '127.0.0.0/8',
    '169.254.0.0/16',  // link-local
    '0.0.0.0/8',
    '::1/128',         // IPv6 loopback
    'fc00::/7',        // IPv6 private
  ];

  // URL 화이트리스트
  private readonly ALLOWED_HOSTS = [
    'api.example.com',
    'cdn.example.com',
  ];

  async validateUrl(urlString: string): Promise<boolean> {
    let url: URL;
    try {
      url = new URL(urlString);
    } catch {
      return false;
    }

    // 프로토콜 제한
    if (!['https:', 'http:'].includes(url.protocol)) return false;

    // 호스트 화이트리스트 확인
    if (this.ALLOWED_HOSTS.length > 0 && !this.ALLOWED_HOSTS.includes(url.hostname)) {
      return false;
    }

    // DNS 확인 후 내부 IP 차단 (DNS Rebinding 방지)
    const addresses = await dns.resolve4(url.hostname);
    for (const addr of addresses) {
      if (this.isPrivateIP(addr)) return false;
    }

    return true;
  }

  private isPrivateIP(ip: string): boolean {
    return net.isIP(ip) !== 0 && (
      ip.startsWith('10.') ||
      ip.startsWith('172.16.') || ip.startsWith('172.17.') /* ... 172.31 */ ||
      ip.startsWith('192.168.') ||
      ip.startsWith('127.') ||
      ip.startsWith('169.254.') ||
      ip === '0.0.0.0'
    );
  }
}

// 사용 예시
app.post('/api/fetch-url', async (req, res) => {
  const ssrf = new SSRFProtection();
  const { url } = req.body;

  if (!(await ssrf.validateUrl(url))) {
    return res.status(400).json({ error: 'URL not allowed' });
  }

  // 타임아웃 설정, 리다이렉트 제한
  const response = await fetch(url, {
    signal: AbortSignal.timeout(5000),
    redirect: 'error', // 리다이렉트 차단
  });

  res.json({ data: await response.text() });
});
```

---

## 3. 인증/인가 심층 가이드

### 3.1 세션 기반 인증

#### 3.1.1 세션 저장소 선택

| 저장소 | 성능 | 확장성 | 영속성 | 적합한 규모 |
|--------|------|--------|--------|------------|
| 메모리 (기본) | 매우 빠름 | 불가 | 없음 | 개발용만 |
| Redis | 빠름 | 클러스터 | 선택적 | 대규모 |
| PostgreSQL | 보통 | DB 확장 | 있음 | 중소규모 |
| MongoDB | 빠름 | 샤딩 | 있음 | 중대규모 |

#### 3.1.2 CSRF 토큰 연동

```typescript
import csrf from 'csurf';

// CSRF 미들웨어 설정
const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
  },
});

// CSRF 토큰 발급
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// CSRF 보호가 필요한 라우트
app.post('/api/transfer', csrfProtection, (req, res) => {
  // 토큰 자동 검증됨
  processTransfer(req.body);
});
```

### 3.2 JWT 기반 인증

#### 3.2.1 Access Token + Refresh Token 전체 플로우

```
1. 클라이언트 -> 서버: POST /auth/login (credentials)
2. 서버: 자격 증명 검증
3. 서버 -> 클라이언트: Access Token (15분) + Refresh Token (7일)
4. 클라이언트 -> 서버: API 요청 + Authorization: Bearer {accessToken}
5. 서버: Access Token 검증 -> 응답
6. Access Token 만료 시:
   6a. 클라이언트 -> 서버: POST /auth/refresh + Refresh Token
   6b. 서버: Refresh Token 검증, Rotation 적용
   6c. 서버 -> 클라이언트: 새 Access Token + 새 Refresh Token
7. Refresh Token 만료/폐기 시:
   7a. 서버 -> 클라이언트: 401 Unauthorized
   7b. 클라이언트: 재로그인 유도
```

#### 3.2.2 서명 알고리즘 선택

| 알고리즘 | 유형 | 키 관리 | 적합한 사용처 |
|---------|------|--------|-------------|
| HS256 | 대칭키 | 단일 키 공유 | 단일 서버, 내부 서비스 |
| RS256 | 비대칭키 | 공개키/비밀키 쌍 | 마이크로서비스, 외부 검증 |
| ES256 | 비대칭키 (ECDSA) | 짧은 키, 빠른 검증 | 모바일, IoT |

#### 3.2.3 토큰 저장 위치 비교

| 저장소 | XSS 취약 | CSRF 취약 | 권장 여부 |
|--------|---------|----------|----------|
| localStorage | 취약 | 안전 | 비권장 |
| sessionStorage | 취약 | 안전 | 비권장 |
| httpOnly 쿠키 | 안전 | 취약 (SameSite로 완화) | 권장 |
| 메모리 (변수) | 안전 | 안전 | 권장 (SPA) |
| httpOnly 쿠키 + CSRF 토큰 | 안전 | 안전 | 가장 권장 |

#### 3.2.4 JWT 전체 구현 (Node.js)

```typescript
import jwt from 'jsonwebtoken';
import crypto from 'crypto';

interface TokenPayload {
  userId: string;
  role: string;
  tokenVersion: number;
}

class JWTAuthService {
  private readonly ACCESS_SECRET = process.env.JWT_ACCESS_SECRET!;
  private readonly REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;
  private readonly ACCESS_EXPIRY = '15m';
  private readonly REFRESH_EXPIRY = '7d';

  // Access Token 생성
  generateAccessToken(payload: TokenPayload): string {
    return jwt.sign(payload, this.ACCESS_SECRET, {
      expiresIn: this.ACCESS_EXPIRY,
      algorithm: 'HS256',
      issuer: 'my-app',
      audience: 'my-app-client',
    });
  }

  // Refresh Token 생성
  generateRefreshToken(payload: TokenPayload): string {
    const jti = crypto.randomUUID(); // 고유 토큰 ID
    return jwt.sign({ ...payload, jti }, this.REFRESH_SECRET, {
      expiresIn: this.REFRESH_EXPIRY,
      algorithm: 'HS256',
    });
  }

  // Access Token 검증
  verifyAccessToken(token: string): TokenPayload {
    return jwt.verify(token, this.ACCESS_SECRET, {
      algorithms: ['HS256'],
      issuer: 'my-app',
      audience: 'my-app-client',
    }) as TokenPayload;
  }

  // Refresh Token 검증 + Rotation
  async refreshTokens(refreshToken: string): Promise<{ accessToken: string; refreshToken: string }> {
    const decoded = jwt.verify(refreshToken, this.REFRESH_SECRET, {
      algorithms: ['HS256'],
    }) as TokenPayload & { jti: string };

    // 토큰 블랙리스트 확인 (Redis)
    const isRevoked = await this.isTokenRevoked(decoded.jti);
    if (isRevoked) throw new Error('Token has been revoked');

    // 사용자 토큰 버전 확인 (비밀번호 변경 시 무효화)
    const user = await this.getUserById(decoded.userId);
    if (user.tokenVersion !== decoded.tokenVersion) {
      throw new Error('Token version mismatch');
    }

    // 기존 Refresh Token 폐기 (Rotation)
    await this.revokeToken(decoded.jti);

    // 새 토큰 쌍 발급
    const payload: TokenPayload = {
      userId: decoded.userId,
      role: decoded.role,
      tokenVersion: decoded.tokenVersion,
    };

    return {
      accessToken: this.generateAccessToken(payload),
      refreshToken: this.generateRefreshToken(payload),
    };
  }

  // 토큰 폐기 (블랙리스트)
  async revokeToken(jti: string): Promise<void> {
    await redis.set(`revoked:${jti}`, '1', 'EX', 7 * 24 * 60 * 60);
  }

  private async isTokenRevoked(jti: string): Promise<boolean> {
    return (await redis.get(`revoked:${jti}`)) !== null;
  }

  private async getUserById(id: string): Promise<any> {
    return db.user.findUnique({ where: { id } });
  }
}

// 인증 미들웨어
function authenticate(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing authorization header' });
  }

  const token = authHeader.substring(7);
  try {
    const payload = jwtService.verifyAccessToken(token);
    req.user = payload;
    next();
  } catch (err) {
    if (err instanceof jwt.TokenExpiredError) {
      return res.status(401).json({ error: 'Token expired', code: 'TOKEN_EXPIRED' });
    }
    return res.status(401).json({ error: 'Invalid token' });
  }
}
```

```java
// JWT 구현 (Spring Boot)
@Service
public class JwtService {
    @Value("${jwt.access-secret}")
    private String accessSecret;

    @Value("${jwt.refresh-secret}")
    private String refreshSecret;

    private static final long ACCESS_EXPIRY_MS = 15 * 60 * 1000; // 15분
    private static final long REFRESH_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7일

    public String generateAccessToken(UserDetails userDetails) {
        return Jwts.builder()
            .setSubject(userDetails.getUsername())
            .claim("role", userDetails.getAuthorities())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + ACCESS_EXPIRY_MS))
            .setIssuer("my-app")
            .signWith(Keys.hmacShaKeyFor(accessSecret.getBytes()), SignatureAlgorithm.HS256)
            .compact();
    }

    public String generateRefreshToken(UserDetails userDetails) {
        String jti = UUID.randomUUID().toString();
        return Jwts.builder()
            .setSubject(userDetails.getUsername())
            .setId(jti)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + REFRESH_EXPIRY_MS))
            .signWith(Keys.hmacShaKeyFor(refreshSecret.getBytes()), SignatureAlgorithm.HS256)
            .compact();
    }

    public Claims validateAccessToken(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(accessSecret.getBytes()))
            .requireIssuer("my-app")
            .build()
            .parseClaimsJws(token)
            .getBody();
    }
}
```

### 3.3 OAuth 2.0 / OIDC

#### 3.3.1 Authorization Code Flow + PKCE

```typescript
import crypto from 'crypto';

// PKCE 코드 생성
function generatePKCE(): { codeVerifier: string; codeChallenge: string } {
  const codeVerifier = crypto.randomBytes(32).toString('base64url');
  const codeChallenge = crypto
    .createHash('sha256')
    .update(codeVerifier)
    .digest('base64url');
  return { codeVerifier, codeChallenge };
}

// 1단계: 인가 요청
app.get('/auth/oauth/start', (req, res) => {
  const { codeVerifier, codeChallenge } = generatePKCE();
  const state = crypto.randomBytes(32).toString('hex');

  // 세션에 저장 (CSRF 방지용)
  req.session.oauthState = state;
  req.session.codeVerifier = codeVerifier;

  const authUrl = new URL('https://provider.example.com/authorize');
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('client_id', process.env.OAUTH_CLIENT_ID!);
  authUrl.searchParams.set('redirect_uri', process.env.OAUTH_REDIRECT_URI!);
  authUrl.searchParams.set('scope', 'openid profile email');
  authUrl.searchParams.set('state', state);
  authUrl.searchParams.set('code_challenge', codeChallenge);
  authUrl.searchParams.set('code_challenge_method', 'S256');

  res.redirect(authUrl.toString());
});

// 2단계: 콜백 처리
app.get('/auth/oauth/callback', async (req, res) => {
  const { code, state } = req.query;

  // State 파라미터 검증 (CSRF 방지)
  if (state !== req.session.oauthState) {
    return res.status(403).json({ error: 'Invalid state parameter' });
  }

  // 코드 교환 -> 토큰
  const tokenResponse = await fetch('https://provider.example.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code as string,
      redirect_uri: process.env.OAUTH_REDIRECT_URI!,
      client_id: process.env.OAUTH_CLIENT_ID!,
      client_secret: process.env.OAUTH_CLIENT_SECRET!,
      code_verifier: req.session.codeVerifier,
    }),
  });

  const tokens = await tokenResponse.json();

  // ID Token 검증 (OIDC)
  const idTokenPayload = await verifyIdToken(tokens.id_token);

  // 사용자 처리
  const user = await findOrCreateUser(idTokenPayload);

  // 세션 정리
  delete req.session.oauthState;
  delete req.session.codeVerifier;

  req.session.userId = user.id;
  res.redirect('/dashboard');
});
```

#### 3.3.2 Implicit Flow (Deprecated)

Implicit Flow는 보안상 이유로 더 이상 권장되지 않는다:
- Access Token이 URL fragment에 노출
- 브라우저 히스토리에 토큰 저장
- 리퍼러 헤더를 통한 토큰 유출
- Refresh Token 발급 불가

대신 Authorization Code Flow + PKCE를 사용해야 한다. SPA에서도 PKCE를 적용할 수 있다.

### 3.4 RBAC / ABAC 구현

#### 3.4.1 미들웨어 기반 접근 제어 (Node.js)

```typescript
// 권한 미들웨어 팩토리
function authorize(options: {
  roles?: string[];
  permissions?: string[];
  ownerCheck?: (req: Request) => Promise<boolean>;
}) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const user = req.user;
    if (!user) return res.status(401).json({ error: 'Unauthorized' });

    // 역할 검사
    if (options.roles && !options.roles.includes(user.role)) {
      logSecurityEvent({ type: 'authz_failure', userId: user.id, ip: req.ip, userAgent: req.get('user-agent') || '', details: { requiredRoles: options.roles, userRole: user.role, path: req.path } });
      return res.status(403).json({ error: 'Insufficient role' });
    }

    // 권한 검사
    if (options.permissions) {
      const userPerms = await getUserPermissions(user.id);
      const hasAll = options.permissions.every(p => userPerms.includes(p));
      if (!hasAll) return res.status(403).json({ error: 'Insufficient permissions' });
    }

    // 리소스 소유권 검사
    if (options.ownerCheck) {
      const isOwner = await options.ownerCheck(req);
      if (!isOwner && user.role !== 'admin') {
        return res.status(403).json({ error: 'Not the resource owner' });
      }
    }

    next();
  };
}

// 사용 예시
app.put('/api/posts/:id',
  authenticate,
  authorize({
    permissions: ['update:posts'],
    ownerCheck: async (req) => {
      const post = await Post.findById(req.params.id);
      return post?.authorId === req.user.id;
    },
  }),
  updatePostHandler
);
```

```java
// Spring Security 접근 제어
@Configuration
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/**").hasAuthority("DELETE_RESOURCE")
                .anyRequest().authenticated()
            )
            .build();
    }
}

// 메서드 레벨 보안
@RestController
@RequestMapping("/api/posts")
public class PostController {

    @GetMapping
    @PreAuthorize("hasAuthority('READ_POSTS')")
    public List<PostDTO> getAllPosts() { ... }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('UPDATE_POSTS') and @postSecurity.isOwner(#id, authentication)")
    public PostDTO updatePost(@PathVariable Long id, @RequestBody PostDTO dto) { ... }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public void deletePost(@PathVariable Long id) { ... }
}

@Component("postSecurity")
public class PostSecurityEvaluator {
    public boolean isOwner(Long postId, Authentication auth) {
        Post post = postRepository.findById(postId).orElseThrow();
        return post.getAuthorId().equals(((UserPrincipal) auth.getPrincipal()).getId());
    }
}
```

#### 3.4.2 프론트엔드 권한 분기 처리

```typescript
// React 권한 컴포넌트
function usePermissions() {
  const { user } = useAuth();
  const permissions = useMemo(() => {
    return rolePermissions[user?.role as Role] || [];
  }, [user?.role]);

  const hasPermission = useCallback((permission: Permission) => {
    return permissions.includes(permission);
  }, [permissions]);

  const hasAnyPermission = useCallback((...perms: Permission[]) => {
    return perms.some(p => permissions.includes(p));
  }, [permissions]);

  return { hasPermission, hasAnyPermission, permissions };
}

// 권한 가드 컴포넌트
function PermissionGate({
  permission,
  children,
  fallback = null,
}: {
  permission: Permission;
  children: React.ReactNode;
  fallback?: React.ReactNode;
}) {
  const { hasPermission } = usePermissions();
  return hasPermission(permission) ? <>{children}</> : <>{fallback}</>;
}

// 사용 예시 - 프론트엔드 권한은 UX 목적이며, 실제 보안은 서버에서 처리
function PostActions({ post }: { post: Post }) {
  return (
    <div>
      <PermissionGate permission={Permission.UPDATE_POSTS}>
        <button onClick={() => editPost(post.id)}>Edit</button>
      </PermissionGate>
      <PermissionGate permission={Permission.DELETE_POSTS}>
        <button onClick={() => deletePost(post.id)}>Delete</button>
      </PermissionGate>
    </div>
  );
}
```

> **주의**: 프론트엔드의 권한 분기는 UX 향상 목적이다. 모든 보안 검증은 반드시 서버측에서 수행해야 한다. 프론트엔드 코드는 사용자가 조작할 수 있으므로 보안 경계로 신뢰할 수 없다.

---

## 4. 입력 검증 & 출력 인코딩

### 4.1 입력 검증 원칙

- **화이트리스트 방식**: 허용된 값만 통과 (블랙리스트보다 항상 우선)
- **서버사이드 검증 필수**: 클라이언트사이드 검증은 UX 목적, 보안 의존 금지
- **정규화 우선**: 검증 전에 입력을 정규화 (유니코드 정규화, 트리밍 등)
- **실패 시 거부**: 검증 실패 시 기본 거부 (fail-closed)
- **다중 계층 검증**: 타입 -> 형식 -> 범위 -> 비즈니스 규칙 순서로 검증

### 4.2 서버사이드 검증

#### 4.2.1 Zod (TypeScript) 스키마 패턴

```typescript
import { z } from 'zod';

// 사용자 생성 스키마
const createUserSchema = z.object({
  email: z.string()
    .email('유효한 이메일 주소를 입력하세요')
    .max(255)
    .toLowerCase()
    .trim(),

  password: z.string()
    .min(12, '비밀번호는 최소 12자 이상이어야 합니다')
    .max(128)
    .regex(/[a-z]/, '소문자를 포함해야 합니다')
    .regex(/[A-Z]/, '대문자를 포함해야 합니다')
    .regex(/\d/, '숫자를 포함해야 합니다')
    .regex(/[!@#$%^&*]/, '특수문자를 포함해야 합니다'),

  name: z.string()
    .min(2)
    .max(100)
    .regex(/^[가-힣a-zA-Z\s]+$/, '이름에 허용되지 않는 문자가 포함되어 있습니다')
    .trim(),

  age: z.number()
    .int()
    .min(0)
    .max(150)
    .optional(),

  role: z.enum(['viewer', 'editor', 'admin']).default('viewer'),

  preferences: z.object({
    theme: z.enum(['light', 'dark']).default('light'),
    language: z.enum(['ko', 'en', 'ja']).default('ko'),
    notifications: z.boolean().default(true),
  }).optional(),
});

type CreateUserInput = z.infer<typeof createUserSchema>;

// 미들웨어로 활용
function validateBody<T>(schema: z.ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = schema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        details: result.error.issues.map(issue => ({
          field: issue.path.join('.'),
          message: issue.message,
        })),
      });
    }
    req.body = result.data; // 정제된 데이터로 교체
    next();
  };
}

app.post('/api/users', validateBody(createUserSchema), createUserHandler);

// 쿼리 파라미터 검증
const paginationSchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  sort: z.enum(['createdAt', 'updatedAt', 'name']).default('createdAt'),
  order: z.enum(['asc', 'desc']).default('desc'),
});

// URL 파라미터 검증
const idParamSchema = z.object({
  id: z.string().uuid('유효한 UUID 형식이어야 합니다'),
});
```

#### 4.2.2 Bean Validation (Java)

```java
// DTO 클래스에 검증 어노테이션
public class CreateUserRequest {

    @NotBlank(message = "이메일은 필수입니다")
    @Email(message = "유효한 이메일 형식이어야 합니다")
    @Size(max = 255)
    private String email;

    @NotBlank(message = "비밀번호는 필수입니다")
    @Size(min = 12, max = 128, message = "비밀번호는 12-128자여야 합니다")
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*]).+$",
        message = "비밀번호는 대소문자, 숫자, 특수문자를 포함해야 합니다"
    )
    private String password;

    @NotBlank
    @Size(min = 2, max = 100)
    @Pattern(regexp = "^[가-힣a-zA-Z\\s]+$", message = "이름에 허용되지 않는 문자가 있습니다")
    private String name;

    @Min(0) @Max(150)
    private Integer age;
}

// 컨트롤러에서 검증 적용
@PostMapping("/api/users")
public ResponseEntity<?> createUser(@Valid @RequestBody CreateUserRequest request,
                                     BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        List<Map<String, String>> errors = bindingResult.getFieldErrors().stream()
            .map(err -> Map.of(
                "field", err.getField(),
                "message", err.getDefaultMessage()
            ))
            .collect(Collectors.toList());
        return ResponseEntity.badRequest().body(Map.of("errors", errors));
    }
    return ResponseEntity.ok(userService.createUser(request));
}

// 커스텀 Validator
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SafeHtmlValidator.class)
public @interface SafeHtml {
    String message() default "HTML 태그가 허용되지 않습니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class SafeHtmlValidator implements ConstraintValidator<SafeHtml, String> {
    private static final Pattern HTML_PATTERN = Pattern.compile("<[^>]*>");

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) return true;
        return !HTML_PATTERN.matcher(value).find();
    }
}
```

#### 4.2.3 파일 업로드 검증

```typescript
import multer from 'multer';
import fileType from 'file-type';

// 허용 파일 타입 정의
const ALLOWED_FILE_TYPES: Record<string, { mimeTypes: string[]; maxSize: number }> = {
  image: {
    mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    maxSize: 5 * 1024 * 1024, // 5MB
  },
  document: {
    mimeTypes: ['application/pdf', 'application/msword'],
    maxSize: 10 * 1024 * 1024, // 10MB
  },
};

// Multer 설정
const upload = multer({
  storage: multer.memoryStorage(), // 메모리에 임시 저장
  limits: {
    fileSize: 10 * 1024 * 1024, // 최대 10MB
    files: 5, // 최대 5개 파일
  },
  fileFilter: (req, file, cb) => {
    // 1. 확장자 검증
    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.pdf'];
    const ext = path.extname(file.originalname).toLowerCase();
    if (!allowedExtensions.includes(ext)) {
      return cb(new Error('허용되지 않는 파일 확장자입니다'));
    }

    // 2. MIME 타입 검증 (Content-Type 헤더)
    const allMimeTypes = Object.values(ALLOWED_FILE_TYPES).flatMap(t => t.mimeTypes);
    if (!allMimeTypes.includes(file.mimetype)) {
      return cb(new Error('허용되지 않는 파일 형식입니다'));
    }

    cb(null, true);
  },
});

// 파일 처리 미들웨어
async function validateFileContent(req: Request, res: Response, next: NextFunction) {
  if (!req.file) return next();

  // 3. 매직 바이트 검증 (실제 파일 내용 확인)
  const detectedType = await fileType.fromBuffer(req.file.buffer);
  if (!detectedType) {
    return res.status(400).json({ error: '파일 형식을 확인할 수 없습니다' });
  }

  const allMimeTypes = Object.values(ALLOWED_FILE_TYPES).flatMap(t => t.mimeTypes);
  if (!allMimeTypes.includes(detectedType.mime)) {
    return res.status(400).json({
      error: '파일 내용이 확장자와 일치하지 않습니다',
    });
  }

  // 4. 파일명 안전 처리
  req.file.originalname = sanitizeFilename(req.file.originalname);

  next();
}

function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-zA-Z0-9가-힣._-]/g, '_') // 안전한 문자만 허용
    .replace(/\.{2,}/g, '.') // 연속 점 제거
    .substring(0, 255); // 길이 제한
}

app.post('/api/upload', upload.single('file'), validateFileContent, uploadHandler);
```

### 4.3 출력 인코딩

#### 4.3.1 컨텍스트별 인코딩 전략

| 출력 컨텍스트 | 인코딩 방법 | 예시 |
|-------------|-----------|------|
| HTML 본문 | HTML Entity 인코딩 | `<` -> `&lt;` |
| HTML 속성 | 속성값 인코딩 + 따옴표 | `"` -> `&quot;` |
| JavaScript | JavaScript 이스케이프 | `'` -> `\'` |
| URL 파라미터 | URL 인코딩 | ` ` -> `%20` |
| CSS | CSS 이스케이프 | `\` -> `\\` |
| JSON | JSON 직렬화 | 자동 이스케이프 |

```typescript
// 프레임워크별 자동 인코딩 확인

// React: JSX에서 자동 이스케이프 (기본 안전)
function UserProfile({ user }) {
  return <div>{user.name}</div>; // 안전 - 자동 이스케이프
}

// [위험] dangerouslySetInnerHTML 사용
function UnsafeContent({ html }) {
  return <div dangerouslySetInnerHTML={{ __html: html }} />; // XSS 위험
}

// [안전] DOMPurify로 새니타이징 후 사용
import DOMPurify from 'dompurify';

function SafeContent({ html }) {
  const sanitized = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href', 'title'],
    ALLOW_DATA_ATTR: false,
  });
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

```java
// Spring/Thymeleaf: 기본 이스케이프
// th:text는 자동 이스케이프 (안전)
// <p th:text="${user.name}">Name</p>

// [위험] th:utext는 이스케이프하지 않음
// <p th:utext="${user.bio}">Bio</p>  -- XSS 위험

// [안전] OWASP Java Encoder 사용
import org.owasp.encoder.Encode;

String safeHtml = Encode.forHtml(userInput);
String safeAttr = Encode.forHtmlAttribute(userInput);
String safeJs = Encode.forJavaScript(userInput);
String safeUrl = Encode.forUriComponent(userInput);
String safeCss = Encode.forCssString(userInput);
```

### 4.4 Content Security Policy 상세

#### 4.4.1 CSP 지시문 설명

| 지시문 | 설명 | 권장 값 |
|--------|------|--------|
| default-src | 기본 리소스 로딩 정책 | `'self'` |
| script-src | JavaScript 소스 제한 | `'self'` + nonce 기반 |
| style-src | CSS 소스 제한 | `'self'` (또는 `'unsafe-inline'` CSS-in-JS) |
| img-src | 이미지 소스 제한 | `'self' data: https:` |
| font-src | 폰트 소스 제한 | `'self'` |
| connect-src | XHR/Fetch/WebSocket 제한 | `'self'` + API 도메인 |
| frame-src | iframe 소스 제한 | `'none'` |
| object-src | 플러그인 소스 제한 | `'none'` |
| base-uri | `<base>` 태그 제한 | `'self'` |
| form-action | 폼 제출 대상 제한 | `'self'` |
| frame-ancestors | 이 페이지를 iframe으로 삽입 가능한 소스 | `'none'` |
| upgrade-insecure-requests | HTTP -> HTTPS 자동 업그레이드 | 포함 |
| report-uri / report-to | CSP 위반 보고 URL | 모니터링 엔드포인트 |

#### 4.4.2 Nonce 기반 인라인 스크립트 허용

```typescript
import crypto from 'crypto';

// CSP nonce 미들웨어
function cspNonce(req: Request, res: Response, next: NextFunction) {
  const nonce = crypto.randomBytes(16).toString('base64');
  res.locals.cspNonce = nonce;

  res.setHeader('Content-Security-Policy', [
    `default-src 'self'`,
    `script-src 'self' 'nonce-${nonce}'`,
    `style-src 'self' 'nonce-${nonce}'`,
    `img-src 'self' data: https:`,
    `font-src 'self'`,
    `connect-src 'self' https://api.example.com`,
    `frame-src 'none'`,
    `object-src 'none'`,
    `base-uri 'self'`,
    `form-action 'self'`,
    `frame-ancestors 'none'`,
    `upgrade-insecure-requests`,
  ].join('; '));

  next();
}
```

#### 4.4.3 단계적 CSP 강화 전략

```
1단계: Report-Only 모드로 시작 (기존 사이트 영향 없음)
   Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report

2단계: 위반 보고 분석 후 정책 조정
   - 필요한 외부 리소스 도메인 추가
   - 인라인 스크립트를 nonce 기반으로 변경

3단계: 점진적 적용 (일부 페이지부터)
   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-xxx'

4단계: 전체 적용 + 지속적 모니터링
   - 위반 보고서 자동 수집
   - 정기적 정책 검토
```

---

## 5. 데이터 보호

### 5.1 민감 데이터 분류

| 분류 | 설명 | 예시 | 보호 수준 |
|------|------|------|----------|
| **PII** (개인식별정보) | 개인을 식별할 수 있는 정보 | 이름, 이메일, 전화번호, 주소 | 암호화 + 접근 제어 |
| **PHI** (보호건강정보) | 건강/의료 관련 정보 | 진료 기록, 처방전, 보험 정보 | 강력한 암호화 + 감사 |
| **PCI** (결제카드정보) | 결제 카드 관련 데이터 | 카드 번호, CVV, 만료일 | PCI DSS 준수 |
| **인증 정보** | 인증에 사용되는 데이터 | 비밀번호, API 키, 토큰 | 해싱/암호화 + 최소 노출 |
| **비즈니스 기밀** | 사업적 가치가 있는 정보 | 계약서, 재무 데이터, 전략 | 접근 제어 + 암호화 |

### 5.2 암호화

#### 5.2.1 전송 중 암호화 (TLS)

```typescript
// Node.js HTTPS 서버 설정
import https from 'https';
import fs from 'fs';

const server = https.createServer({
  key: fs.readFileSync('/etc/ssl/private/server.key'),
  cert: fs.readFileSync('/etc/ssl/certs/server.crt'),
  ca: fs.readFileSync('/etc/ssl/certs/ca.crt'),

  // TLS 최소 버전
  minVersion: 'TLSv1.2',

  // 강력한 암호 스위트
  ciphers: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256',
    'ECDHE-RSA-AES256-GCM-SHA384',
  ].join(':'),

  // Perfect Forward Secrecy
  ecdhCurve: 'prime256v1:secp384r1',
}, app);
```

#### 5.2.2 필드 레벨 암호화

```typescript
// 데이터베이스 필드 레벨 암호화
class EncryptedField {
  private encryptor: FieldEncryptor;
  private keyId: string;

  constructor(keyId: string) {
    this.encryptor = new FieldEncryptor();
    this.keyId = keyId;
  }

  // Prisma 미들웨어로 자동 암호화/복호화
  middleware(): Prisma.Middleware {
    return async (params, next) => {
      // 쓰기 시 암호화
      if (['create', 'update'].includes(params.action)) {
        const sensitiveFields = ['ssn', 'phoneNumber', 'address'];
        for (const field of sensitiveFields) {
          if (params.args.data?.[field]) {
            const key = await this.getKey(this.keyId);
            const encrypted = this.encryptor.encrypt(params.args.data[field], key);
            params.args.data[field] = JSON.stringify(encrypted);
          }
        }
      }

      const result = await next(params);

      // 읽기 시 복호화
      if (result && ['findUnique', 'findFirst', 'findMany'].includes(params.action)) {
        await this.decryptResult(result);
      }

      return result;
    };
  }

  private async getKey(keyId: string): Promise<Buffer> {
    // KMS에서 키 조회 (캐시 적용)
    return kmsClient.getKey(keyId);
  }
}
```

### 5.3 시크릿 관리

#### 5.3.1 환경변수 관리 패턴

```bash
# .env.example (커밋됨 - 필요한 변수 문서화)
DATABASE_URL=postgresql://user:pass@localhost:5432/dbname
JWT_ACCESS_SECRET=your-access-secret-here
JWT_REFRESH_SECRET=your-refresh-secret-here
REDIS_URL=redis://localhost:6379
AWS_REGION=ap-northeast-2

# .env (커밋 금지)
DATABASE_URL=postgresql://prod_user:actual_password@db.example.com:5432/prod_db
JWT_ACCESS_SECRET=actual-256-bit-secret
```

```gitignore
# .gitignore - 시크릿 파일 제외
.env
.env.local
.env.*.local
*.pem
*.key
credentials.json
service-account.json
```

#### 5.3.2 Git에서 시크릿 유출 방지

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.18.0
    hooks:
      - id: gitleaks

  - repo: https://github.com/awslabs/git-secrets
    rev: master
    hooks:
      - id: git-secrets
```

```toml
# gitleaks.toml - 커스텀 규칙
[extend]
useDefault = true

[[rules]]
id = "custom-api-key"
description = "Custom API Key Pattern"
regex = '''(?i)(api[_-]?key|apikey)\s*[:=]\s*['\"]?([a-zA-Z0-9]{32,})['\"]?'''
tags = ["key", "api"]

[[rules]]
id = "korean-rrn"
description = "Korean Resident Registration Number"
regex = '''\d{6}[-]\d{7}'''
tags = ["pii", "korean"]

[allowlist]
paths = [
  '''\.env\.example''',
  '''.*test.*''',
  '''.*mock.*''',
]
```

#### 5.3.3 HashiCorp Vault 연동

```typescript
import Vault from 'node-vault';

class SecretManager {
  private vault;

  constructor() {
    this.vault = Vault({
      endpoint: process.env.VAULT_ADDR,
      token: process.env.VAULT_TOKEN,
    });
  }

  async getSecret(path: string): Promise<Record<string, string>> {
    const result = await this.vault.read(`secret/data/${path}`);
    return result.data.data;
  }

  async getDatabaseCredentials(): Promise<{ username: string; password: string }> {
    // 동적 시크릿: 임시 DB 자격 증명 생성
    const result = await this.vault.read('database/creds/app-role');
    return {
      username: result.data.username,
      password: result.data.password,
    };
    // 리스 만료 시 자동으로 자격 증명 폐기됨
  }
}
```

### 5.4 개인정보 보호

#### 5.4.1 데이터 최소 수집 원칙

```typescript
// [위험] 불필요한 데이터까지 수집/반환
app.get('/api/users/:id', async (req, res) => {
  const user = await prisma.user.findUnique({
    where: { id: req.params.id },
  });
  res.json(user); // 모든 필드 반환 (비밀번호 해시 포함 가능)
});

// [안전] 필요한 필드만 선택적 반환
app.get('/api/users/:id', async (req, res) => {
  const user = await prisma.user.findUnique({
    where: { id: req.params.id },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      createdAt: true,
      // passwordHash, ssn, phoneNumber 등 제외
    },
  });
  res.json(user);
});
```

#### 5.4.2 데이터 마스킹

```typescript
// 민감 데이터 마스킹 유틸리티
class DataMasker {
  static email(email: string): string {
    const [local, domain] = email.split('@');
    return `${local[0]}***@${domain}`;
  }

  static phone(phone: string): string {
    return phone.replace(/(\d{3})(\d{4})(\d{4})/, '$1-****-$3');
  }

  static name(name: string): string {
    if (name.length <= 1) return '*';
    return name[0] + '*'.repeat(name.length - 1);
  }

  static creditCard(number: string): string {
    return '****-****-****-' + number.slice(-4);
  }

  static ssn(ssn: string): string {
    return '******-*******';
  }
}

// 로깅 시 자동 마스킹
function maskSensitiveData(data: Record<string, unknown>): Record<string, unknown> {
  const sensitiveFields: Record<string, (v: string) => string> = {
    email: DataMasker.email,
    phone: DataMasker.phone,
    phoneNumber: DataMasker.phone,
    creditCard: DataMasker.creditCard,
    ssn: DataMasker.ssn,
    password: () => '[REDACTED]',
    token: () => '[REDACTED]',
    authorization: () => '[REDACTED]',
  };

  const masked = { ...data };
  for (const [key, maskFn] of Object.entries(sensitiveFields)) {
    if (typeof masked[key] === 'string') {
      masked[key] = maskFn(masked[key] as string);
    }
  }
  return masked;
}
```

#### 5.4.3 삭제 요청 처리 (GDPR Right to Erasure)

```typescript
// 사용자 데이터 삭제 처리
class UserDataDeletionService {
  async processDeleteRequest(userId: string): Promise<void> {
    // 1. 삭제 요청 기록 (감사 추적)
    await this.logDeletionRequest(userId);

    // 2. 사용자 데이터 익명화 (완전 삭제 대신)
    await prisma.user.update({
      where: { id: userId },
      data: {
        email: `deleted_${crypto.randomUUID()}@deleted.local`,
        name: 'Deleted User',
        phoneNumber: null,
        address: null,
        profileImage: null,
        deletedAt: new Date(),
        isDeleted: true,
      },
    });

    // 3. 관련 데이터 처리
    await prisma.userSession.deleteMany({ where: { userId } });
    await prisma.apiKey.deleteMany({ where: { userId } });

    // 4. 외부 서비스 데이터 삭제 요청
    await this.requestExternalDataDeletion(userId);

    // 5. 백업에서 제외 표시
    await this.markForBackupExclusion(userId);

    // 6. 처리 완료 알림
    await this.notifyDeletionComplete(userId);
  }
}
```

---

## 6. API 보안

### 6.1 인증 방식 비교

| 방식 | 보안 수준 | 사용 편의성 | 적합한 사용처 |
|------|----------|-----------|-------------|
| API Key | 낮음 | 높음 | 서버 간 통신, 공개 API |
| Bearer Token (JWT) | 중간-높음 | 중간 | 사용자 인증, SPA |
| OAuth 2.0 | 높음 | 낮음 | 3rd-party 통합, SSO |
| mTLS | 매우 높음 | 낮음 | 마이크로서비스 간 통신 |
| HMAC 서명 | 높음 | 중간 | Webhook, API 무결성 |

### 6.2 Rate Limiting

#### 6.2.1 알고리즘 비교

| 알고리즘 | 설명 | 장점 | 단점 |
|---------|------|------|------|
| Fixed Window | 고정 시간 창 단위 카운트 | 구현 간단 | 경계 시점 버스트 |
| Sliding Window | 이동 시간 창 카운트 | 균일한 제한 | 메모리 사용 높음 |
| Token Bucket | 토큰 소비 방식 | 버스트 허용 | 구현 복잡 |
| Leaky Bucket | 일정 속도 처리 | 균일한 속도 | 유연성 부족 |

```typescript
// Redis 기반 Sliding Window Rate Limiter
class SlidingWindowRateLimiter {
  constructor(
    private redis: Redis,
    private limit: number,
    private windowMs: number
  ) {}

  async isAllowed(key: string): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {
    const now = Date.now();
    const windowStart = now - this.windowMs;
    const redisKey = `ratelimit:${key}`;

    const pipeline = this.redis.pipeline();
    pipeline.zremrangebyscore(redisKey, 0, windowStart); // 만료된 항목 제거
    pipeline.zadd(redisKey, now, `${now}-${Math.random()}`); // 현재 요청 추가
    pipeline.zcard(redisKey); // 총 요청 수
    pipeline.pexpire(redisKey, this.windowMs); // TTL 설정

    const results = await pipeline.exec();
    const count = results![2][1] as number;

    if (count > this.limit) {
      // 초과 시 마지막 추가한 항목 제거
      await this.redis.zremrangebyscore(redisKey, now, now);
      return {
        allowed: false,
        remaining: 0,
        resetAt: windowStart + this.windowMs,
      };
    }

    return {
      allowed: true,
      remaining: this.limit - count,
      resetAt: now + this.windowMs,
    };
  }
}

// 미들웨어 적용
function rateLimitMiddleware(limiter: SlidingWindowRateLimiter) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = req.user?.id || req.ip;
    const result = await limiter.isAllowed(key);

    res.set({
      'X-RateLimit-Limit': String(limiter.limit),
      'X-RateLimit-Remaining': String(result.remaining),
      'X-RateLimit-Reset': String(result.resetAt),
    });

    if (!result.allowed) {
      return res.status(429).json({
        error: 'Too many requests',
        retryAfter: Math.ceil((result.resetAt - Date.now()) / 1000),
      });
    }

    next();
  };
}
```

### 6.3 API 에러 응답 설계

```typescript
// 일관된 에러 응답 포맷
interface ApiError {
  error: {
    code: string;        // 기계 판독용 에러 코드
    message: string;     // 사용자 친화적 메시지
    details?: unknown[]; // 상세 정보 (검증 에러 등)
  };
  requestId: string;     // 추적용 ID
}

// [위험] 내부 정보 노출
res.status(500).json({
  error: 'Database connection failed: ECONNREFUSED 192.168.1.50:5432',
  query: 'SELECT * FROM users WHERE...',
});

// [안전] 최소 정보 노출
res.status(500).json({
  error: {
    code: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred',
  },
  requestId: 'req_abc123',
});

// 에러 코드 매핑
const ERROR_MESSAGES: Record<number, { code: string; message: string }> = {
  400: { code: 'BAD_REQUEST', message: 'The request was invalid' },
  401: { code: 'UNAUTHORIZED', message: 'Authentication is required' },
  403: { code: 'FORBIDDEN', message: 'You do not have permission to access this resource' },
  404: { code: 'NOT_FOUND', message: 'The requested resource was not found' },
  409: { code: 'CONFLICT', message: 'The request conflicts with the current state' },
  422: { code: 'UNPROCESSABLE', message: 'The request data is invalid' },
  429: { code: 'RATE_LIMITED', message: 'Too many requests, please try again later' },
  500: { code: 'INTERNAL_ERROR', message: 'An unexpected error occurred' },
};
```

### 6.4 GraphQL 보안

```typescript
import depthLimit from 'graphql-depth-limit';
import { createComplexityLimitRule } from 'graphql-validation-complexity';

// GraphQL 보안 설정
const server = new ApolloServer({
  typeDefs,
  resolvers,
  validationRules: [
    // 1. 쿼리 깊이 제한 (중첩 공격 방지)
    depthLimit(10),

    // 2. 쿼리 복잡성 제한
    createComplexityLimitRule(1000, {
      scalarCost: 1,
      objectCost: 10,
      listFactor: 20,
    }),
  ],

  // 3. 인트로스펙션 비활성화 (프로덕션)
  introspection: process.env.NODE_ENV !== 'production',

  // 4. 요청 크기 제한
  plugins: [
    {
      async requestDidStart() {
        return {
          async didResolveOperation(requestContext) {
            // 쿼리 크기 제한
            if (requestContext.request.query && requestContext.request.query.length > 10000) {
              throw new Error('Query too large');
            }
          },
        };
      },
    },
  ],
});
```

### 6.5 WebSocket 보안

```typescript
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({
  server: httpsServer,
  maxPayload: 1024 * 1024, // 1MB 메시지 크기 제한
  verifyClient: (info, callback) => {
    // 1. Origin 검증
    const origin = info.origin;
    if (!allowedOrigins.includes(origin)) {
      callback(false, 403, 'Forbidden origin');
      return;
    }

    // 2. 인증 검증
    const token = new URL(info.req.url!, `https://${info.req.headers.host}`).searchParams.get('token');
    if (!token) {
      callback(false, 401, 'Missing authentication');
      return;
    }

    try {
      const payload = jwtService.verifyAccessToken(token);
      (info.req as any).user = payload;
      callback(true);
    } catch {
      callback(false, 401, 'Invalid token');
    }
  },
});

wss.on('connection', (ws, req) => {
  const user = (req as any).user;

  // 연결별 Rate Limiting
  let messageCount = 0;
  const resetInterval = setInterval(() => { messageCount = 0; }, 60000);

  ws.on('message', (data) => {
    messageCount++;
    if (messageCount > 60) { // 분당 60개 메시지 제한
      ws.close(1008, 'Rate limit exceeded');
      return;
    }

    // 메시지 크기 검증
    if (data.toString().length > 10000) {
      ws.send(JSON.stringify({ error: 'Message too large' }));
      return;
    }

    // 메시지 처리
    try {
      const message = JSON.parse(data.toString());
      handleMessage(user, message);
    } catch {
      ws.send(JSON.stringify({ error: 'Invalid message format' }));
    }
  });

  ws.on('close', () => {
    clearInterval(resetInterval);
  });
});
```

### 6.6 파일 업로드 보안 (API)

```typescript
// 안전한 파일 저장 경로 생성
function generateSafeStoragePath(originalName: string): string {
  const ext = path.extname(originalName).toLowerCase();
  const safeFilename = `${crypto.randomUUID()}${ext}`;
  const dateFolder = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  return path.join('uploads', dateFolder, safeFilename);
}

// 파일 저장 후 처리
async function handleFileUpload(file: Express.Multer.File): Promise<string> {
  const storagePath = generateSafeStoragePath(file.originalname);
  const absolutePath = path.resolve(UPLOAD_DIR, storagePath);

  // 경로 이탈 방지
  if (!absolutePath.startsWith(path.resolve(UPLOAD_DIR))) {
    throw new Error('Invalid storage path');
  }

  // 디렉토리 생성
  await fs.mkdir(path.dirname(absolutePath), { recursive: true });

  // 파일 저장
  await fs.writeFile(absolutePath, file.buffer);

  // 실행 권한 제거
  await fs.chmod(absolutePath, 0o644);

  return storagePath;
}
```

---

## 7. 인프라 & DevSecOps

### 7.1 Docker 보안

```dockerfile
# 보안 강화 Dockerfile (멀티스테이지 빌드)

# 빌드 단계
FROM node:20-alpine AS builder
WORKDIR /app

# 의존성 설치 (캐시 활용)
COPY package.json package-lock.json ./
RUN npm ci --ignore-scripts

# 소스 복사 및 빌드
COPY . .
RUN npm run build

# 프로덕션 의존성만 설치
RUN npm ci --only=production --ignore-scripts

# 실행 단계
FROM node:20-alpine

# 보안 패치 적용
RUN apk update && apk upgrade --no-cache

# 비루트 사용자 생성
RUN addgroup -g 1001 -S app && \
    adduser -S app -u 1001 -G app

WORKDIR /app

# 프로덕션 파일만 복사
COPY --from=builder --chown=app:app /app/dist ./dist
COPY --from=builder --chown=app:app /app/node_modules ./node_modules
COPY --from=builder --chown=app:app /app/package.json ./

# 비루트 사용자로 전환
USER app

# 헬스체크
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => { process.exit(r.statusCode === 200 ? 0 : 1) })"

EXPOSE 3000

CMD ["node", "dist/server.js"]
```

```yaml
# docker-compose.yml 보안 설정
services:
  app:
    build: .
    read_only: true
    tmpfs:
      - /tmp
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
    environment:
      - NODE_ENV=production
    secrets:
      - db_password
      - jwt_secret

secrets:
  db_password:
    file: ./secrets/db_password.txt
  jwt_secret:
    file: ./secrets/jwt_secret.txt
```

### 7.2 CI/CD 보안

#### 7.2.1 보안 파이프라인 전체 구성

```yaml
# GitHub Actions - 종합 보안 파이프라인
name: Security Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 6 * * 1' # 매주 월요일 6시 스캔

permissions:
  contents: read
  security-events: write

jobs:
  # 1. 시크릿 스캔
  secret-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 2. SAST (정적 분석)
  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/owasp-top-ten
            p/nodejs
            p/typescript
            p/security-audit

  # 3. SCA (의존성 분석)
  sca:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm audit --production --audit-level=high
      - name: Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  # 4. 컨테이너 이미지 스캔
  container-scan:
    runs-on: ubuntu-latest
    needs: [sast, sca]
    steps:
      - uses: actions/checkout@v4
      - name: Build image
        run: docker build -t app:${{ github.sha }} .
      - name: Trivy scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: app:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  # 5. DAST (동적 분석) - 스테이징 배포 후
  dast:
    runs-on: ubuntu-latest
    needs: [container-scan]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: ZAP Scan
        uses: zaproxy/action-full-scan@v0.8.0
        with:
          target: ${{ secrets.STAGING_URL }}
          rules_file_name: '.zap/rules.tsv'
```

### 7.3 보안 테스트 도구 비교

#### 7.3.1 SAST (Static Application Security Testing)

| 도구 | 언어 지원 | 라이선스 | 특징 |
|------|----------|---------|------|
| SonarQube | 25+ 언어 | Community/Enterprise | 종합 코드 품질 + 보안 |
| Semgrep | 30+ 언어 | 오픈소스/유료 | 빠름, 커스텀 규칙 용이 |
| CodeQL | 주요 언어 | GitHub 무료 | 의미론적 분석, 깊은 탐지 |
| ESLint Security | JavaScript/TS | 오픈소스 | 가볍고 빠름, 기본 수준 |

#### 7.3.2 DAST (Dynamic Application Security Testing)

| 도구 | 유형 | 라이선스 | 특징 |
|------|------|---------|------|
| OWASP ZAP | 프록시/스캐너 | 오픈소스 | 가장 인기 있는 무료 도구 |
| Nuclei | 템플릿 스캐너 | 오픈소스 | 빠름, 커뮤니티 템플릿 |
| Burp Suite | 프록시/스캐너 | 유료 | 전문 침투 테스트 |

#### 7.3.3 시크릿 스캐닝

| 도구 | 스캔 대상 | 라이선스 | 특징 |
|------|----------|---------|------|
| gitleaks | Git 히스토리 | 오픈소스 | pre-commit 지원 |
| trufflehog | Git 히스토리 | 오픈소스 | 엔트로피 기반 탐지 |
| GitHub Secret Scanning | GitHub 리포 | GitHub 무료 | 자동 알림 |
| detect-secrets (Yelp) | 파일 시스템 | 오픈소스 | 베이스라인 기반 |

### 7.4 사고 대응 체크리스트

#### 7.4.1 사고 대응 단계별 체크리스트

```markdown
## 1단계: 탐지 (Detection)
- [ ] 이상 징후 확인 (로그, 모니터링 알림)
- [ ] 사고 범위 초기 평가
- [ ] 사고 심각도 분류 (P1-Critical, P2-High, P3-Medium, P4-Low)
- [ ] 대응 팀 소집 및 역할 분담
- [ ] 커뮤니케이션 채널 설정

## 2단계: 격리 (Containment)
- [ ] 영향받는 시스템 식별
- [ ] 네트워크 격리 (필요 시)
- [ ] 감염/침해 계정 비활성화
- [ ] 백업 무결성 확인
- [ ] 증거 보존 (로그, 스냅샷)

## 3단계: 분석 (Analysis)
- [ ] 공격 벡터 파악
- [ ] 침해 시작 시점 확인
- [ ] 영향받은 데이터 범위 파악
- [ ] 타임라인 작성
- [ ] 인디케이터 (IOC) 추출

## 4단계: 복구 (Recovery)
- [ ] 취약점 패치/수정
- [ ] 시스템 복원 (클린 이미지)
- [ ] 비밀번호/키/토큰 로테이션
- [ ] 모니터링 강화
- [ ] 단계적 서비스 복구

## 5단계: 교훈 (Lessons Learned)
- [ ] 사후 분석 보고서 작성
- [ ] 근본 원인 분석 (5 Whys)
- [ ] 재발 방지 대책 수립
- [ ] 보안 정책/절차 업데이트
- [ ] 교육 및 훈련 계획
```

---

## 8. 보안 체크리스트

### 8.1 개발 단계 체크리스트

코딩 시 반드시 확인해야 할 보안 항목:

```markdown
## 인증/인가
- [ ] 모든 API 엔드포인트에 인증 적용
- [ ] 리소스 접근 시 소유권/권한 검증
- [ ] 비밀번호는 bcrypt/Argon2로 해싱
- [ ] JWT 토큰에 적절한 만료 시간 설정 (Access: 15분, Refresh: 7일)
- [ ] 세션 고정(fixation) 방지: 로그인 후 세션 재생성
- [ ] 관리자 기능에 역할 기반 접근 제어 적용

## 입력 검증
- [ ] 모든 사용자 입력에 서버사이드 검증 적용
- [ ] SQL 쿼리에 파라미터 바인딩 사용 (문자열 연결 금지)
- [ ] 파일 업로드 시 MIME 타입, 매직 바이트, 크기, 확장자 검증
- [ ] URL/경로 입력에 디렉토리 트래버설 방지
- [ ] 화이트리스트 기반 입력 검증

## 출력 인코딩
- [ ] 컨텍스트에 맞는 출력 인코딩 적용 (HTML, JS, URL, CSS)
- [ ] dangerouslySetInnerHTML / v-html 사용 시 DOMPurify로 새니타이징
- [ ] Content-Security-Policy 헤더 설정
- [ ] API 에러 응답에 내부 정보 노출 방지

## 데이터 보호
- [ ] 민감 데이터 전송 시 HTTPS 사용
- [ ] 비밀번호, 토큰, 키가 로그에 기록되지 않음
- [ ] .env 파일이 .gitignore에 포함
- [ ] 민감 필드 암호화 적용 (SSN, 카드번호 등)
- [ ] API 응답에 필요한 필드만 포함 (select 사용)

## 의존성
- [ ] npm audit 통과 (high/critical 취약점 없음)
- [ ] 의존성 버전 고정 (lock 파일 커밋)
- [ ] 사용하지 않는 의존성 제거
```

### 8.2 코드 리뷰 보안 체크리스트

PR 리뷰 시 확인할 보안 항목:

```markdown
## 접근 제어
- [ ] 새 엔드포인트에 적절한 인증/인가 미들웨어 적용
- [ ] 리소스 접근 시 소유권 검증 (수평적 권한 상승 방지)
- [ ] 관리자 전용 기능에 역할 검증

## 인젝션 방지
- [ ] 동적 쿼리에 문자열 연결 대신 파라미터 바인딩 사용
- [ ] exec/eval 사용 금지 또는 안전성 확인
- [ ] 사용자 입력이 HTML에 직접 삽입되지 않음
- [ ] 리다이렉트 URL의 도메인 검증

## 시크릿 관리
- [ ] 하드코딩된 시크릿 없음 (API 키, 비밀번호, 토큰)
- [ ] 시크릿이 로그에 출력되지 않음
- [ ] 시크릿이 에러 메시지에 포함되지 않음
- [ ] 환경변수로 시크릿 관리

## 에러 처리
- [ ] 스택 트레이스가 클라이언트에 노출되지 않음
- [ ] 에러 메시지에 시스템 정보 포함되지 않음 (DB 구조, 경로 등)
- [ ] 적절한 에러 코드 사용 (401 vs 403 구분)

## 데이터 노출
- [ ] API 응답에 불필요한 필드 포함되지 않음
- [ ] 디버그 로그에 민감 데이터 포함되지 않음
- [ ] 주석에 민감 정보 포함되지 않음
```

### 8.3 배포 전 체크리스트

릴리스 전 확인할 보안 항목:

```markdown
## 환경 설정
- [ ] NODE_ENV=production 설정
- [ ] 디버그 모드 비활성화
- [ ] 불필요한 엔드포인트 제거/비활성화 (/debug, /test, /swagger)
- [ ] 기본 계정/비밀번호 변경
- [ ] CORS 허용 오리진이 프로덕션 도메인만 포함

## 보안 헤더
- [ ] Content-Security-Policy 설정
- [ ] Strict-Transport-Security (HSTS) 설정
- [ ] X-Content-Type-Options: nosniff
- [ ] X-Frame-Options: DENY
- [ ] Referrer-Policy 설정
- [ ] Permissions-Policy 설정

## TLS/인증서
- [ ] TLS 1.2 이상 사용
- [ ] 강력한 암호 스위트 설정
- [ ] 인증서 만료일 확인
- [ ] HTTP -> HTTPS 리다이렉트 설정

## 인프라
- [ ] 컨테이너가 비루트 사용자로 실행
- [ ] 불필요한 포트 차단
- [ ] 데이터베이스 외부 접근 차단
- [ ] 시크릿이 Vault/환경변수로 관리
- [ ] 로그 수집 및 모니터링 설정

## 스캔 결과
- [ ] SAST 스캔 통과 (critical/high 없음)
- [ ] SCA 스캔 통과 (알려진 취약점 없음)
- [ ] 컨테이너 이미지 스캔 통과
- [ ] 시크릿 스캔 통과 (유출 없음)
```

### 8.4 운영 체크리스트

운영 환경에서 정기적으로 확인할 항목:

```markdown
## 모니터링 (일일)
- [ ] 비정상 로그인 시도 확인
- [ ] API 에러율 모니터링 (4xx, 5xx)
- [ ] Rate Limiting 트리거 확인
- [ ] 보안 알림 검토

## 패치 관리 (주간)
- [ ] OS/런타임 보안 패치 확인
- [ ] 의존성 취약점 스캔 (npm audit, Snyk)
- [ ] 보안 권고 확인 (CVE, 프레임워크 보안 공지)

## 접근 관리 (월간)
- [ ] 사용자 계정 및 권한 검토
- [ ] 불필요한 API 키/토큰 폐기
- [ ] 서비스 계정 비밀번호 순환
- [ ] 접근 로그 감사

## 인프라 (분기)
- [ ] 침투 테스트 실시
- [ ] 재해 복구 계획 테스트
- [ ] 백업 복구 테스트
- [ ] 인증서 만료일 확인
- [ ] 보안 정책 검토 및 업데이트

## 교육 (연간)
- [ ] 개발팀 보안 교육
- [ ] 보안 사고 대응 훈련
- [ ] 신규 위협/취약점 동향 교육
- [ ] OWASP Top 10 업데이트 검토
```

---

## 부록: 보안 참조 자료

### 주요 참고 문서
| 자료 | URL | 설명 |
|------|-----|------|
| OWASP Top 10 | owasp.org/Top10 | 웹 보안 취약점 Top 10 |
| OWASP Cheat Sheet | cheatsheetseries.owasp.org | 보안 구현 가이드 |
| CWE | cwe.mitre.org | 공통 약점 목록 |
| NIST Cybersecurity | nist.gov/cyberframework | 사이버보안 프레임워크 |
| Mozilla Web Security | infosec.mozilla.org | 웹 보안 가이드라인 |

### 보안 코딩 규칙 요약

| 원칙 | 설명 |
|------|------|
| 입력 불신 | 모든 외부 입력은 악의적일 수 있다 |
| 심층 방어 | 단일 보안 계층에 의존하지 않는다 |
| 최소 권한 | 필요한 최소한의 권한만 부여한다 |
| 안전한 기본값 | 기본 설정은 가장 안전한 상태여야 한다 |
| 실패 시 안전 | 오류 발생 시 안전한 상태로 복구한다 |
| 단순성 유지 | 보안 메커니즘은 단순할수록 안전하다 |
| 공개 설계 | 보안은 비밀에 의존하지 않는다 (Kerckhoffs 원칙) |
| 완전한 중재 | 모든 접근을 검증한다 |
| 분리 | 권한과 기능을 분리한다 |
| 감사 추적 | 모든 보안 관련 이벤트를 기록한다 |

---

> 이 문서는 지속적으로 업데이트되어야 합니다. 새로운 보안 위협이 발견되거나 모범 사례가 변경될 때마다 관련 섹션을 수정하세요.
> 마지막 업데이트: 2025
